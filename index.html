<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ä½é¢‘å™ªéŸ³åˆ†æå™¨ + çƒ­åŠ›å›¾</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; text-align: center; margin: 0; }
    canvas { background: #000; display: block; margin: 0 auto; }
    .controls { margin-top: 10px; }
    button {
      margin: 0.5rem; padding: 0.5rem 1rem;
      background: #333; color: #fff; border: none;
      cursor: pointer; border-radius: 5px;
    }
    button:hover { background: #555; }
  </style>
</head>
<body>
  <h1>ğŸ§ é«˜é¢‘è°± + çƒ­åŠ›å›¾åˆ†æå™¨ï¼ˆä½é¢‘ä¸“ç”¨ï¼‰</h1>
  <canvas id="spectrumCanvas" width="1024" height="400"></canvas>
  <canvas id="heatmapCanvas" width="1024" height="200"></canvas>
  <div class="controls">
    <button id="toggleBtn">â–¶ï¸ å¼€å§‹</button>
    <button id="toggleModeBtn">ğŸ“Š åˆ‡æ¢æŸ±çŠ¶/æ›²çº¿</button>
    <button id="toggleScaleBtn">ğŸ“‰ åˆ‡æ¢çº¿æ€§/å¯¹æ•° Xè½´</button>
    <button id="clearBtn">ğŸ§¹ æ¸…ç©ºçƒ­åŠ›å›¾</button>
  </div>
  <script>
    const specCanvas = document.getElementById("spectrumCanvas");
    const specCtx = specCanvas.getContext("2d");
    const heatCanvas = document.getElementById("heatmapCanvas");
    const heatCtx = heatCanvas.getContext("2d");

    let audioCtx, analyser;
    let bufferLength, sampleRate;
    let floatData, avgData;
    let isPaused = true;
    let isLogScale = false;
    let useBarChart = true;
    let animationId;
    const smoothingFactor = 0.8;
    const heatHistory = [];
    const maxHistory = heatCanvas.height;

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s == 0) r = g = b = l;
      else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function draw() {
      if (isPaused) return;
      animationId = requestAnimationFrame(draw);
      analyser.getFloatFrequencyData(floatData);
      for (let i = 0; i < bufferLength; i++) {
        avgData[i] = smoothingFactor * avgData[i] + (1 - smoothingFactor) * floatData[i];
      }

      // ç»˜åˆ¶é¢‘è°±å›¾
      specCtx.fillStyle = "#000";
      specCtx.fillRect(0, 0, specCanvas.width, specCanvas.height);
      const barWidth = specCanvas.width / bufferLength;
      const peaks = [];

      for (let i = 0; i < bufferLength; i++) {
        const dB = avgData[i];
        const height = ((dB + 120) / 120) * specCanvas.height;
        const x = isLogScale
          ? Math.log10(1 + i) / Math.log10(1 + bufferLength) * specCanvas.width
          : i * barWidth;
        const nextX = isLogScale
          ? Math.log10(1 + i + 1) / Math.log10(1 + bufferLength) * specCanvas.width
          : (i + 1) * barWidth;
        if (useBarChart) {
          specCtx.fillStyle = `hsl(${(i / bufferLength) * 360}, 100%, 50%)`;
          specCtx.fillRect(x, specCanvas.height - height, nextX - x, height);
        } else {
          const y = specCanvas.height - height;
          if (i === 0) specCtx.beginPath();
          else specCtx.lineTo(x, y);
        }
        peaks.push({ index: i, value: dB });
      }
      if (!useBarChart) {
        specCtx.strokeStyle = "#0f0";
        specCtx.lineWidth = 2;
        specCtx.stroke();
      }

      // yè½´åˆ»åº¦
      specCtx.strokeStyle = "#444";
      specCtx.fillStyle = "#ccc";
      specCtx.font = "12px sans-serif";
      specCtx.textAlign = "right";
      for (let dB = 0; dB >= -120; dB -= 20) {
        const y = specCanvas.height * (1 - (dB + 120) / 120);
        specCtx.setLineDash([4, 4]);
        specCtx.beginPath();
        specCtx.moveTo(35, y);
        specCtx.lineTo(specCanvas.width, y);
        specCtx.stroke();
        specCtx.setLineDash([]);
        specCtx.fillText(`${dB}`, 30, y + 4);
      }

      // xè½´åˆ»åº¦
      specCtx.fillStyle = "#ccc";
      specCtx.textAlign = "left";
      [50, 100, 300, 1000].forEach(freq => {
        const norm = freq / (sampleRate / 2);
        const bin = norm * bufferLength;
        const x = isLogScale
          ? Math.log10(1 + bin) / Math.log10(1 + bufferLength) * specCanvas.width
          : norm * specCanvas.width;
        specCtx.beginPath();
        specCtx.moveTo(x, specCanvas.height - 10);
        specCtx.lineTo(x, specCanvas.height);
        specCtx.stroke();
        specCtx.fillText(`${freq}Hz`, x + 2, specCanvas.height - 5);
      });

      // Top3 peaks
      peaks.sort((a, b) => b.value - a.value);
      const top3 = peaks.slice(0, 3);
      specCtx.fillStyle = "#ff0";
      specCtx.font = "14px sans-serif";
      top3.forEach(peak => {
        const freq = peak.index * sampleRate / 2 / bufferLength;
        const dB = peak.value;
        const x = isLogScale
          ? Math.log10(1 + peak.index) / Math.log10(1 + bufferLength) * specCanvas.width
          : peak.index * barWidth;
        const y = specCanvas.height - ((dB + 120) / 120) * specCanvas.height;
        specCtx.beginPath();
        specCtx.arc(x, y, 4, 0, 2 * Math.PI);
        specCtx.fill();
        specCtx.fillText(`ğŸ”º${Math.round(freq)}Hz ${dB.toFixed(1)}dB`, x + 6, y - 6);
      });

      // çƒ­åŠ›å›¾æ›´æ–°
      const row = new Uint8ClampedArray(bufferLength * 4);
      for (let i = 0; i < bufferLength; i++) {
        const dB = avgData[i];
        const norm = Math.max(0, Math.min(1, (dB + 100) / 100));
        const hue = (1 - norm) * 240;
        const color = hslToRgb(hue / 360, 1, 0.5);
        row[i * 4 + 0] = color[0];
        row[i * 4 + 1] = color[1];
        row[i * 4 + 2] = color[2];
        row[i * 4 + 3] = 255;
      }
      heatHistory.push(row);
      if (heatHistory.length > maxHistory) heatHistory.shift();

      const imageData = heatCtx.createImageData(heatCanvas.width, heatHistory.length);
      for (let y = 0; y < heatHistory.length; y++) {
        const src = heatHistory[y];
        for (let x = 0; x < heatCanvas.width; x++) {
          const norm = x / heatCanvas.width;
          const bin = isLogScale
            ? Math.pow(10, norm * Math.log10(1 + bufferLength)) - 1
            : norm * bufferLength;
          const idx = Math.min(bufferLength - 1, Math.floor(bin)) * 4;
          const pixelIndex = (y * heatCanvas.width + x) * 4;
          imageData.data[pixelIndex + 0] = src[idx + 0];
          imageData.data[pixelIndex + 1] = src[idx + 1];
          imageData.data[pixelIndex + 2] = src[idx + 2];
          imageData.data[pixelIndex + 3] = 255;
        }
      }
      heatCtx.putImageData(imageData, 0, heatCanvas.height - heatHistory.length);
    }

    document.getElementById("toggleBtn").addEventListener("click", () => {
      isPaused = !isPaused;
      document.getElementById("toggleBtn").textContent = isPaused ? "â–¶ï¸ å¼€å§‹" : "â¸ï¸ æš‚åœ";
      if (!isPaused) draw();
      else cancelAnimationFrame(animationId);
    });

    document.getElementById("toggleModeBtn").addEventListener("click", () => {
      useBarChart = !useBarChart;
    });

    document.getElementById("toggleScaleBtn").addEventListener("click", () => {
      isLogScale = !isLogScale;
    });

    document.getElementById("clearBtn").addEventListener("click", () => {
      heatHistory.length = 0;
      heatCtx.clearRect(0, 0, heatCanvas.width, heatCanvas.height);
    });

    navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sampleRate = audioCtx.sampleRate;
      const source = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 8192;
      bufferLength = analyser.frequencyBinCount;
      floatData = new Float32Array(bufferLength);
      avgData = new Float32Array(bufferLength);
      source.connect(analyser);
    });
  </script>
</body>
</html>
